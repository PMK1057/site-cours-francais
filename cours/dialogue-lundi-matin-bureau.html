<!-- Import Google Fonts Inter -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<div class="back-button-container">
    <button class="back-btn" onclick="backToSection('dialogues')">‚Üê Retour aux Dialogues</button>
</div>

<h1 style="text-align: center; font-size: 2rem; font-weight: bold; color: #1f2937; margin-bottom: 8px;">üíº Lundi matin au bureau</h1>
<p class="course-intro" style="text-align: center; color: #6b7280; font-size: 0.95rem; margin-bottom: 30px;">Dialogue informel entre deux coll√®gues au bureau. Pratiquez votre compr√©hension orale et votre prononciation avec les lecteurs audio interactifs.</p>

<!-- Contr√¥les globaux -->
<div id="dialogue-controls" style="max-width: 800px; margin: 20px auto; display: flex; align-items: center; justify-content: center; gap: 15px; padding: 15px; background: #f8f9fa; border-radius: 15px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
    <button id="play-all-btn" onclick="togglePlayAll()" style="width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; color: white; cursor: pointer; font-size: 20px; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4); transition: all 0.3s; display: flex; align-items: center; justify-content: center;">
        <span id="play-all-icon">‚ñ∂</span>
    </button>
    <label style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #4b5563;">
        <span>Vitesse:</span>
        <select id="speed-select" onchange="updateGlobalSpeed()" style="padding: 5px 10px; border-radius: 5px; border: 1px solid #d1d5db;">
            <option value="0.5">0.5x</option>
            <option value="0.7">0.7x</option>
            <option value="0.85">0.85x</option>
            <option value="1.0" selected>1.0x</option>
            <option value="1.2">1.2x</option>
            <option value="1.5">1.5x</option>
        </select>
    </label>
</div>

<div id="dialogue-container" class="dialogue-container">
    <!-- Le dialogue sera charg√© dynamiquement depuis dialogue-data.json -->
</div>

<style>
/* Container principal style chat */
.dialogue-container {
    max-width: 800px;
    margin: 40px auto;
    padding: 30px 20px;
    min-height: 200px;
    background: #f8f9fa;
    border-radius: 20px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.08);
}

/* Bulles de messages style chat */
.dialogue-line {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    margin-bottom: 20px;
    position: relative;
    /* Transition uniquement pour les propri√©t√©s non-critiques (pas de all) */
    transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    padding: 12px;
    border-radius: 12px;
}

/* Ligne active (en cours de lecture) */
.dialogue-line.active {
    background: rgba(102, 126, 234, 0.1);
    border: 2px solid #667eea;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
}

/* Bulle align√©e √† gauche (premi√®re personne) */
.dialogue-line.left {
    justify-content: flex-start;
}

/* Bulle align√©e √† droite (deuxi√®me personne) */
.dialogue-line.right {
    justify-content: flex-end;
    flex-direction: row-reverse;
}

/* Avatar circulaire */
.speaker-avatar {
    flex-shrink: 0;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    font-size: 16px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transition: all 0.3s;
}

.dialogue-line.active .speaker-avatar {
    transform: scale(1.1);
    box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4);
}

/* Avatar pour personne 1 (gauche) - bleu/violet */
.dialogue-line.left .speaker-avatar {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

/* Avatar pour personne 2 (droite) - rose/corail */
.dialogue-line.right .speaker-avatar {
    background: linear-gradient(135deg, #ff5e7a 0%, #ff84a3 100%);
}

/* Contenu de la bulle */
.dialogue-content {
    max-width: 75%;
    position: relative;
}

@media (max-width: 640px) {
    .dialogue-content {
        max-width: 85%;
    }
}

/* Bulle de message */
.message-bubble {
    padding: 14px 18px;
    border-radius: 20px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    /* Transition uniquement pour box-shadow et transform (pas de all) */
    transition: box-shadow 0.3s ease, transform 0.3s ease;
    position: relative;
    /* Emp√™cher les transitions de se propager aux enfants */
    isolation: isolate;
}

.dialogue-line.left .message-bubble {
    background: linear-gradient(135deg, #e0e7ff 0%, #e9d5ff 100%);
    border-top-left-radius: 4px;
}

.dialogue-line.right .message-bubble {
    background: linear-gradient(135deg, #fce7f3 0%, #ffe4e6 100%);
    border-top-right-radius: 4px;
}

.dialogue-line:hover .message-bubble {
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    transform: translateY(-2px);
}

/* Nom du locuteur */
.speaker-name {
    font-weight: 600;
    color: #4b5563;
    margin-bottom: 8px;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    opacity: 0.85;
    display: block;
}

/* Texte du message avec karaok√© - Style Moderne √âl√©gant */
.dialogue-text {
    color: #2d3748;
    line-height: 1.75;
    font-size: 17px;
    margin-bottom: 10px;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    font-weight: 400;
    letter-spacing: -0.01em;
}

/* Mots individuels - structure avec deux textes superpos√©s */
.dialogue-text .word {
    /* AUCUNE transition - tout doit √™tre instantan√© */
    transition: none !important;
    transition-property: none !important;
    transition-duration: 0s !important;
    padding: 3px 6px;
    border-radius: 6px;
    display: inline-block;
    position: relative;
    z-index: 1;
    margin: 0 1px;
    /* Background transparent par d√©faut */
    background-color: transparent !important;
    color: transparent !important; /* Rendre le texte de base transparent */
    /* Pr√©parer le navigateur pour les changements rapides */
    will-change: transform;
    /* Forcer l'isolation pour √©viter les h√©ritages de transition */
    isolation: isolate;
    contain: layout style paint;
}

/* Texte normal (non surlign√©) - prend sa place dans le flux */
.dialogue-text .word .word-text-normal {
    position: relative;
    z-index: 2;
    color: #2d3748;
    font-weight: 400;
    opacity: 1;
    transition: none !important;
    transition-property: none !important;
    transition-duration: 0s !important;
    pointer-events: none;
    display: inline;
    visibility: visible;
}

/* Texte en gras (surlign√©) - toujours pr√©sent, superpos√© exactement */
.dialogue-text .word .word-text-bold {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 3;
    color: #2d3748;
    font-weight: 600;
    letter-spacing: 0.02em;
    opacity: 0;
    transition: none !important;
    transition-property: none !important;
    transition-duration: 0s !important;
    pointer-events: none;
    white-space: nowrap;
    visibility: hidden; /* Cach√© par d√©faut pour performance */
}

/* Texte en gras visible quand surlign√© */
.dialogue-text .word.highlighted .word-text-bold {
    visibility: visible;
    opacity: 1 !important;
}

/* Mot surlign√© - afficher le texte en gras, cacher le normal */
.dialogue-text .word.highlighted .word-text-normal {
    opacity: 0 !important;
    transition: none !important;
}

.dialogue-text .word.highlighted .word-text-bold {
    opacity: 1 !important;
    transition: none !important;
}

/* Overlay - toujours pr√©sent avec le background, on change juste l'opacit√© */
.word-highlight-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 6px;
    z-index: 0; /* Derri√®re le texte mais au-dessus du background */
    pointer-events: none;
    background-color: #a78bfa;
    box-shadow: 
        0 2px 8px rgba(167, 139, 250, 0.3),
        0 0 0 1px rgba(167, 139, 250, 0.2);
    opacity: 0;
    transition: none !important;
    transition-property: none !important;
    transition-duration: 0s !important;
    contain: strict;
}

/* Overlay actif - on change UNIQUEMENT l'opacit√© (plus rapide que background-color) */
.dialogue-text .word.highlighted .word-highlight-overlay {
    opacity: 1 !important;
    transition: none !important;
    transition-property: none !important;
}

/* Overlay inactif - opacit√© √† 0 */
.dialogue-text .word:not(.highlighted) .word-highlight-overlay {
    opacity: 0 !important;
    transition: none !important;
    transition-property: none !important;
}

/* Mot en attente (prochain) - Opacit√© r√©duite */
.dialogue-text .word.pending .word-text-normal {
    color: #9ca3af;
    opacity: 0.4 !important;
}

.dialogue-text .word.pending .word-text-bold {
    opacity: 0 !important;
}

/* Overlay de mise en √©vidence - AUCUNE transition, toujours pr√©sent */
.word-highlight-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 6px;
    z-index: -1;
    pointer-events: none;
    background-color: transparent;
    transition: none !important;
    transition-property: none !important;
    transition-duration: 0s !important;
    transition-delay: 0s !important;
    will-change: background-color;
    transform: translateZ(0);
    isolation: isolate;
    /* Forcer le rendu imm√©diat */
    opacity: 1 !important;
    visibility: visible !important;
    /* Emp√™cher tout h√©ritage de transition */
    contain: strict;
}

/* D√©sactiver COMPL√àTEMENT toutes les transitions sur les mots et leurs enfants */
.dialogue-text {
    isolation: isolate;
    contain: layout style paint;
}

.dialogue-text .word,
.dialogue-text .word *,
.dialogue-text .word::before,
.dialogue-text .word::after {
    transition: none !important;
    transition-property: none !important;
    transition-duration: 0s !important;
    transition-delay: 0s !important;
    transition-timing-function: none !important;
    animation-duration: 0s !important;
    animation-delay: 0s !important;
    /* Force l'isolation pour emp√™cher les transitions h√©rit√©es */
    isolation: isolate;
    /* Emp√™cher la propagation des transitions depuis les parents */
    contain: layout style paint;
}

/* S'assurer que l'overlay n'a jamais de transition */
.word-highlight-overlay,
.word-highlight-overlay * {
    transition: none !important;
    transition-property: none !important;
    transition-duration: 0s !important;
    transition-delay: 0s !important;
}

/* Animation pulse subtile sur le dernier mot surlign√© */
@keyframes highlightPulse {
    0%, 100% {
        box-shadow: 
            0 2px 8px rgba(167, 139, 250, 0.3),
            0 0 0 1px rgba(167, 139, 250, 0.2);
    }
    50% {
        box-shadow: 
            0 4px 16px rgba(167, 139, 250, 0.5),
            0 0 0 2px rgba(167, 139, 250, 0.3);
    }
}

/* Appliquer l'animation au dernier mot surlign√© - mais seulement sur l'overlay pour √©viter les transitions */
.dialogue-text .word.highlighted:last-of-type .word-highlight-overlay {
    animation: highlightPulse 1.5s ease-in-out infinite;
    /* S'assurer que l'animation ne cr√©e pas de transition visible */
    animation-delay: 0.1s;
}

/* D√©sactiver l'animation directement sur le mot pour √©viter les conflits */
.dialogue-text .word.highlighted:last-of-type {
    animation: none !important;
}

/* Responsive : ajuster la taille sur mobile */
@media (max-width: 640px) {
    .dialogue-text {
        font-size: 16px;
        line-height: 1.7;
    }
    
    .dialogue-text .word {
        padding: 2px 5px;
    }
}

/* Desktop : taille l√©g√®rement plus grande */
@media (min-width: 1024px) {
    .dialogue-text {
        font-size: 18px;
        line-height: 1.8;
    }
}

/* Animation pour les bulles */
@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.dialogue-line {
    animation: slideIn 0.3s ease;
}

.dialogue-line:nth-child(even) {
    animation-delay: 0.05s;
}

/* Animation pulse pour le bouton play */
@keyframes pulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.05);
    }
}

#play-all-btn.playing {
    animation: pulse 2s ease-in-out infinite;
}

audio {
    display: none;
}
</style>

<script>
let dialogueData = null;
let isPlaying = false;
let currentLineIndex = -1;
let audioElements = [];
let globalSpeed = 1.0;
let lastUpdateTime = 0;
const UPDATE_THROTTLE = 16; // ~60fps (16ms entre chaque update)

// Charger et afficher le dialogue
async function loadDialogue() {
    console.log('üé¨ loadDialogue() appel√©e');
    const container = document.getElementById('dialogue-container');
    
    if (!container) {
        console.error('‚ùå dialogue-container non trouv√© dans le DOM');
        return;
    }
    
    container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">Chargement du dialogue...</p>';
    
    try {
        let response;
        const paths = [
            '/dialogues/dialogue-data.json',
            '/dialogue-data.json',
            './dialogues/dialogue-data.json',
            '../dialogues/dialogue-data.json',
            '/public/dialogue-data.json'
        ];
        
        let loaded = false;
        for (const path of paths) {
            try {
                response = await fetch(path);
                if (response.ok) {
                    loaded = true;
                    console.log('‚úÖ Fichier charg√© depuis:', path);
                    break;
                }
            } catch (e) {
                continue;
            }
        }
        
        if (!loaded || !response.ok) {
            // Fallback : utiliser les donn√©es directement
            console.warn('‚ö†Ô∏è Impossible de charger le JSON, utilisation des donn√©es en dur');
            const fallbackData = [{
                "id": "dialogue1",
                "title": "Lundi matin au bureau",
                "lines": [
                    {"speaker": "Julie", "text": "Salut Marc ! √áa va ?", "audioPath": "/dialogues/audio/dialogue1_line0.mp3"},
                    {"speaker": "Marc", "text": "Bof, pas terrible... J'ai pas bien dormi ce week-end. Et toi ?", "audioPath": "/dialogues/audio/dialogue1_line1.mp3"},
                    {"speaker": "Julie", "text": "Ouais, √ßa va. Un peu fatigu√©e aussi. T'as fait quoi ce week-end ?", "audioPath": "/dialogues/audio/dialogue1_line2.mp3"},
                    {"speaker": "Marc", "text": "Pas grand-chose, j'ai regard√© des s√©ries. Et toi ?", "audioPath": "/dialogues/audio/dialogue1_line3.mp3"},
                    {"speaker": "Julie", "text": "Pareil, j'ai pas boug√© de chez moi. Bon, allez, bon courage pour aujourd'hui !", "audioPath": "/dialogues/audio/dialogue1_line4.mp3"},
                    {"speaker": "Marc", "text": "Merci, toi aussi !", "audioPath": "/dialogues/audio/dialogue1_line5.mp3"}
                ]
            }];
            dialogueData = fallbackData.find(d => d.id === 'dialogue1');
            if (dialogueData) {
                renderDialogue(container, dialogueData);
                return;
            }
            throw new Error('Impossible de charger dialogue-data.json');
        }
        
        const dialogues = await response.json();
        dialogueData = dialogues.find(d => d.id === 'dialogue1');
        
        if (!dialogueData) {
            container.innerHTML = 
                '<div style="color: red; text-align: center; padding: 20px;">' +
                '<h3>‚ùå Dialogue non trouv√©</h3>' +
                '</div>';
            return;
        }
        
        renderDialogue(container, dialogueData);
    } catch (error) {
        console.error('Erreur lors du chargement du dialogue:', error);
        const container = document.getElementById('dialogue-container');
        container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #d32f2f;">
                <h3>‚ùå Erreur de chargement</h3>
                <p>${error.message}</p>
                <button onclick="loadDialogue()" style="margin-top: 20px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    üîÑ R√©essayer
                </button>
            </div>
        `;
    }
}

function renderDialogue(container, dialogue) {
    if (!container) return;
    
    // Corriger les chemins audio si n√©cessaire
    const correctedLines = dialogue.lines.map(line => {
        let audioPath = line.audioPath;
        if (audioPath.startsWith('/audio/')) {
            audioPath = audioPath.replace('/audio/', '/dialogues/audio/');
        } else if (audioPath.startsWith('/public/audio/')) {
            audioPath = audioPath.replace('/public/audio/', '/dialogues/audio/');
        }
        return { ...line, audioPath };
    });
    
    // D√©terminer l'alignement altern√©
    const speakers = [...new Set(correctedLines.map(l => l.speaker))];
    const speakerAlignment = {};
    speakers.forEach((speaker, idx) => {
        speakerAlignment[speaker] = idx % 2 === 0 ? 'left' : 'right';
    });
    
    // Diviser le texte en mots pour le karaok√©
    function splitTextIntoWords(text) {
        return text.split(/(\s+)/).filter(w => w.length > 0);
    }
    
    const htmlContent = correctedLines.map((line, index) => {
        const alignment = speakerAlignment[line.speaker] || 'left';
        const words = splitTextIntoWords(line.text);
            const wordsHTML = words.map((word, wordIndex) => {
            const isWord = word.trim().length > 0;
            // √âchapper le HTML pour les textes
            const escapedWord = word.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return `<span class="word" data-word-index="${wordIndex}" data-line-index="${index}">
                <span class="word-text-normal">${escapedWord}</span>
                <span class="word-text-bold">${escapedWord}</span>
                <span class="word-highlight-overlay"></span>
            </span>`;
        }).join('');
        
        return `
            <div class="dialogue-line ${alignment}" id="line-${index}" data-line-index="${index}">
                <div class="speaker-avatar">${line.speaker.charAt(0)}</div>
                <div class="dialogue-content">
                    <div class="message-bubble">
                        <div class="speaker-name">${line.speaker}</div>
                        <div class="dialogue-text">${wordsHTML}</div>
                        <audio id="audio-${index}" src="${line.audioPath}" preload="metadata"></audio>
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    container.innerHTML = htmlContent;
    
    // CR√âER les overlays pour tous les mots d√®s le d√©but
    // Cela √©vite de les cr√©er √† la vol√©e et garantit qu'ils sont pr√™ts
    setTimeout(() => {
        const allWords = container.querySelectorAll('.word');
        allWords.forEach(word => {
            // S'assurer que l'overlay existe
            if (!word.querySelector('.word-highlight-overlay')) {
                const overlay = document.createElement('span');
                overlay.className = 'word-highlight-overlay';
                overlay.style.cssText = 'position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: transparent; border-radius: 6px; z-index: -1; pointer-events: none; transition: none !important; will-change: background-color; transform: translateZ(0);';
                word.style.position = 'relative';
                word.style.zIndex = '1';
                word.style.isolation = 'isolate';
                word.appendChild(overlay);
            }
        });
    }, 0);
    
    // Initialiser les √©l√©ments audio
    audioElements = correctedLines.map((line, index) => {
        const audio = document.getElementById(`audio-${index}`);
        if (audio) {
            audio.playbackRate = globalSpeed;
        }
        return audio;
    });
}

function togglePlayAll() {
    if (isPlaying) {
        pauseAll();
    } else {
        playAll();
    }
}

async function playAll() {
    if (!dialogueData || audioElements.length === 0) return;
    
    isPlaying = true;
    const playBtn = document.getElementById('play-all-btn');
    const playIcon = document.getElementById('play-all-icon');
    playBtn.classList.add('playing');
    playIcon.textContent = '‚è∏';
    
    for (let i = 0; i < audioElements.length; i++) {
        if (!isPlaying) break; // Arr√™t si pause
        
        currentLineIndex = i;
        const lineElement = document.getElementById(`line-${i}`);
        const audio = audioElements[i];
        
        if (!audio || !lineElement) continue;
        
        // Mettre en surbrillance la ligne active
        document.querySelectorAll('.dialogue-line').forEach(line => {
            line.classList.remove('active');
        });
        lineElement.classList.add('active');
        
        // Scroll vers la ligne
        lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // R√©initialiser le karaok√©
        resetKaraoke(i);
        
        // Jouer l'audio avec karaok√©
        try {
            await playAudioWithKaraoke(audio, i);
            
            // Micro-pause entre les lignes (500ms)
            if (i < audioElements.length - 1 && isPlaying) {
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        } catch (error) {
            console.error(`Erreur lors de la lecture de la ligne ${i}:`, error);
        }
    }
    
    // Fin de la lecture
    isPlaying = false;
    currentLineIndex = -1;
    playBtn.classList.remove('playing');
    playIcon.textContent = '‚ñ∂';
    document.querySelectorAll('.dialogue-line').forEach(line => {
        line.classList.remove('active');
    });
    resetAllKaraoke();
}

function pauseAll() {
    isPlaying = false;
    audioElements.forEach(audio => {
        if (audio) {
            audio.pause();
            audio.currentTime = 0;
        }
    });
    const playBtn = document.getElementById('play-all-btn');
    const playIcon = document.getElementById('play-all-icon');
    playBtn.classList.remove('playing');
    playIcon.textContent = '‚ñ∂';
    document.querySelectorAll('.dialogue-line').forEach(line => {
        line.classList.remove('active');
    });
    resetAllKaraoke();
}

function playAudioWithKaraoke(audio, lineIndex) {
    return new Promise((resolve, reject) => {
        audio.playbackRate = globalSpeed;
        
        // Pr√©charger le premier mot avant de commencer
        const lineElement = document.getElementById(`line-${lineIndex}`);
        if (lineElement) {
            const firstWord = lineElement.querySelector(`.word[data-line-index="${lineIndex}"]`);
            if (firstWord) {
                // Pr√©parer le premier mot (sans l'activer encore)
                firstWord.style.willChange = 'background, color';
            }
        }
        
        const updateKaraoke = () => {
            if (!isPlaying) return;
            
            // Throttle les mises √† jour pour √©viter les saccades
            const now = performance.now();
            if (now - lastUpdateTime < UPDATE_THROTTLE) {
                return;
            }
            lastUpdateTime = now;
            
            const currentTime = audio.currentTime;
            const duration = audio.duration;
            
            if (duration > 0) {
                // Anticiper plus agressivement le surlignage (0.15s d'avance)
                // Cela compense le d√©lai de rendu du background et la latence audio
                const anticipationOffset = 0.15 / duration;
                const progress = Math.min(1, (currentTime / duration) + anticipationOffset);
                // Appeler directement de mani√®re synchrone
                updateKaraokeHighlight(lineIndex, progress);
            }
        };
        
        // Mettre √† jour imm√©diatement au d√©but
        updateKaraoke();
        
        audio.addEventListener('timeupdate', updateKaraoke);
        audio.addEventListener('ended', () => {
            audio.removeEventListener('timeupdate', updateKaraoke);
            resolve();
        }, { once: true });
        audio.addEventListener('error', (e) => {
            audio.removeEventListener('timeupdate', updateKaraoke);
            reject(e);
        }, { once: true });
        
        audio.play().catch(reject);
    });
}

// Cache pour √©viter les recalculs inutiles
let lastHighlightState = new Map();

function updateKaraokeHighlight(lineIndex, progress) {
    const lineElement = document.getElementById(`line-${lineIndex}`);
    if (!lineElement) return;
    
    const words = lineElement.querySelectorAll(`.word[data-line-index="${lineIndex}"]`);
    const wordCount = words.length;
    
    // Utiliser Math.ceil et ajouter 1 pour √™tre encore plus en avance
    const highlightedCount = Math.min(wordCount, Math.ceil(wordCount * progress) + 1);
    
    // V√©rifier si on a d√©j√† appliqu√© cet √©tat (√©vite les changements inutiles)
    if (lastHighlightState.get(lineIndex) === highlightedCount) {
        return; // Pas de changement n√©cessaire
    }
    lastHighlightState.set(lineIndex, highlightedCount);
    
    // APPROCHE ULTIME : Utiliser directement les propri√©t√©s DOM sans passer par CSS
    // et forcer le rendu avec getComputedStyle
    
    // Pr√©parer tous les changements d'abord
    const updates = [];
    
    words.forEach((word, index) => {
        const shouldBeHighlighted = index < highlightedCount;
        const shouldBePending = index === highlightedCount && progress < 1;
        const isHighlighted = word.classList.contains('highlighted');
        const isPending = word.classList.contains('pending');
        
        if (shouldBeHighlighted && !isHighlighted) {
            updates.push({
                word: word,
                class: 'highlighted',
                removeClass: 'pending'
            });
        } else if (shouldBePending && !isPending) {
            updates.push({
                word: word,
                class: 'pending',
                removeClass: 'highlighted'
            });
        } else if (!shouldBeHighlighted && !shouldBePending && (isHighlighted || isPending)) {
            updates.push({
                word: word,
                class: null,
                removeClass: 'highlighted pending'
            });
        }
    });
    
    if (updates.length === 0) return;
    
    // APPROCHE SIMPLE : Utiliser UNIQUEMENT les classes CSS, JAMAIS de styles inline
    // Le CSS g√®re tout, y compris le background de l'overlay
    updates.forEach(({ word, class: className, removeClass }) => {
        // S'assurer que l'overlay existe (devrait d√©j√† exister depuis renderDialogue)
        let overlay = word.querySelector('.word-highlight-overlay');
        if (!overlay) {
            overlay = document.createElement('span');
            overlay.className = 'word-highlight-overlay';
            word.style.position = 'relative';
            word.style.zIndex = '1';
            word.appendChild(overlay);
        }
        
        // G√©rer UNIQUEMENT les classes - le CSS fait tout le reste
        if (removeClass) {
            word.classList.remove(...removeClass.split(' '));
        }
        if (className) {
            word.classList.add(className);
        }
    });
    
    // Forcer un reflow imm√©diat pour que les classes CSS soient appliqu√©es
    void lineElement.offsetHeight;
}

function resetKaraoke(lineIndex) {
    const lineElement = document.getElementById(`line-${lineIndex}`);
    if (!lineElement) return;
    
    const words = lineElement.querySelectorAll(`.word[data-line-index="${lineIndex}"]`);
    words.forEach(word => {
        word.classList.remove('highlighted', 'pending');
        // R√©initialiser l'overlay
        const overlay = word.querySelector('.word-highlight-overlay');
        if (overlay) {
            overlay.style.setProperty('background-color', 'transparent', 'important');
        }
        // S'assurer que le texte reste dans sa couleur normale
        word.style.setProperty('color', '#2d3748', 'important');
        word.style.setProperty('background-color', 'transparent', 'important');
    });
}

function resetAllKaraoke() {
    document.querySelectorAll('.word').forEach(word => {
        word.classList.remove('highlighted', 'pending');
        // R√©initialiser l'overlay
        const overlay = word.querySelector('.word-highlight-overlay');
        if (overlay) {
            overlay.style.setProperty('background-color', 'transparent', 'important');
        }
        // S'assurer que le texte reste dans sa couleur normale
        word.style.setProperty('color', '#2d3748', 'important');
        word.style.setProperty('background-color', 'transparent', 'important');
    });
}

function updateGlobalSpeed() {
    const select = document.getElementById('speed-select');
    globalSpeed = parseFloat(select.value);
    
    // Mettre √† jour la vitesse de tous les audios
    audioElements.forEach(audio => {
        if (audio) {
            audio.playbackRate = globalSpeed;
        }
    });
}

// Charger le dialogue au chargement de la page
function initDialogue() {
    const container = document.getElementById('dialogue-container');
    if (container) {
        loadDialogue();
    } else {
        setTimeout(initDialogue, 100);
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(initDialogue, 100);
    });
} else {
    setTimeout(initDialogue, 100);
}
</script>
