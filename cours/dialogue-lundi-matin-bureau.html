<!-- Import Google Fonts Inter -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<div class="back-button-container">
    <button class="back-btn" onclick="backToSection('dialogues')">‚Üê Retour aux Dialogues</button>
</div>

<h1 style="text-align: center; font-size: 2rem; font-weight: bold; color: #1f2937; margin-bottom: 8px;">üíº Lundi matin au bureau</h1>
<p class="course-intro" style="text-align: center; color: #6b7280; font-size: 0.95rem; margin-bottom: 30px;">Dialogue informel entre deux coll√®gues au bureau. Pratiquez votre compr√©hension orale et votre prononciation avec les lecteurs audio interactifs.</p>

<!-- Contr√¥les globaux - Sticky pour rester visible pendant le scroll -->
<div id="dialogue-controls" class="dialogue-controls-sticky">
    <div class="dialogue-controls-content">
        <button id="play-all-btn" onclick="togglePlayAll()" class="play-all-btn">
            <span id="play-all-icon">‚ñ∂</span>
        </button>
        <label class="speed-control">
            <span>Vitesse:</span>
            <select id="speed-select" onchange="updateGlobalSpeed()">
                <option value="0.5">0.5x</option>
                <option value="0.7">0.7x</option>
                <option value="0.85">0.85x</option>
                <option value="1.0" selected>1.0x</option>
                <option value="1.2">1.2x</option>
                <option value="1.5">1.5x</option>
            </select>
        </label>
    </div>
</div>

<div id="dialogue-container" class="dialogue-container">
    <!-- Le dialogue sera charg√© dynamiquement depuis dialogue-data.json -->
</div>

<style>
/* Contr√¥les sticky - restent visibles pendant le scroll */
.dialogue-controls-sticky {
    position: sticky;
    top: 20px;
    z-index: 1000;
    max-width: 800px;
    margin: 0 auto 20px auto;
    padding: 0 20px;
}

.dialogue-controls-content {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    padding: 12px 20px;
    background: rgba(255, 255, 255, 0.98);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 25px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.12);
    border: 1px solid rgba(255, 255, 255, 0.8);
}

.play-all-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border: none;
    color: white;
    cursor: pointer;
    font-size: 20px;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.play-all-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(102, 126, 234, 0.5);
}

.speed-control {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    color: #4b5563;
}

.speed-control select {
    padding: 5px 10px;
    border-radius: 5px;
    border: 1px solid #d1d5db;
    background: white;
    cursor: pointer;
}

/* Container principal style chat */
.dialogue-container {
    max-width: 800px;
    margin: 40px auto;
    padding: 30px 20px;
    min-height: 200px;
    background: #f8f9fa;
    border-radius: 20px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.08);
}

/* Bulles de messages style chat */
.dialogue-line {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    margin-bottom: 20px;
    position: relative;
    /* Transition uniquement pour les propri√©t√©s non-critiques (pas de all) */
    transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    padding: 12px;
    border-radius: 12px;
}

/* Ligne active (en cours de lecture) */
.dialogue-line.active {
    background: rgba(102, 126, 234, 0.1);
    border: 2px solid #667eea;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
}

/* Bulle align√©e √† gauche (premi√®re personne) */
.dialogue-line.left {
    justify-content: flex-start;
}

/* Bulle align√©e √† droite (deuxi√®me personne) */
.dialogue-line.right {
    justify-content: flex-end;
    flex-direction: row-reverse;
}

/* Avatar circulaire */
.speaker-avatar {
    flex-shrink: 0;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    font-size: 16px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transition: all 0.3s;
}

.dialogue-line.active .speaker-avatar {
    transform: scale(1.1);
    box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4);
}

/* Avatar pour personne 1 (gauche) - bleu/violet */
.dialogue-line.left .speaker-avatar {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

/* Avatar pour personne 2 (droite) - rose/corail */
.dialogue-line.right .speaker-avatar {
    background: linear-gradient(135deg, #ff5e7a 0%, #ff84a3 100%);
}

/* Contenu de la bulle */
.dialogue-content {
    max-width: 75%;
    position: relative;
}

@media (max-width: 640px) {
    .dialogue-content {
        max-width: 85%;
    }
}

/* Bulle de message */
.message-bubble {
    padding: 14px 18px;
    border-radius: 20px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    /* Transition uniquement pour box-shadow et transform (pas de all) */
    transition: box-shadow 0.3s ease, transform 0.3s ease;
    position: relative;
    /* Emp√™cher les transitions de se propager aux enfants */
    isolation: isolate;
}

.dialogue-line.left .message-bubble {
    background: linear-gradient(135deg, #e0e7ff 0%, #e9d5ff 100%);
    border-top-left-radius: 4px;
}

.dialogue-line.right .message-bubble {
    background: linear-gradient(135deg, #fce7f3 0%, #ffe4e6 100%);
    border-top-right-radius: 4px;
}

.dialogue-line:hover .message-bubble {
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    transform: translateY(-2px);
}

/* Nom du locuteur */
.speaker-name {
    font-weight: 600;
    color: #4b5563;
    margin-bottom: 8px;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    opacity: 0.85;
    display: block;
}

/* Texte du message avec karaok√© - Style Moderne √âl√©gant */
.dialogue-text {
    color: #2d3748;
    line-height: 1.75;
    font-size: 17px;
    margin-bottom: 10px;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    font-weight: 400;
    letter-spacing: -0.01em;
}

/* Mots individuels - SIMPLIFI√â SANS TRANSITIONS */
.dialogue-text .word {
    padding: 3px 6px;
    border-radius: 6px;
    display: inline-block;
    position: relative;
    margin: 0 1px;
    background-color: transparent;
    color: #2d3748;
    font-weight: 400;
}

/* Mot surlign√© - BACKGROUND VIOLET/ROSE VISIBLE */
.dialogue-text .word.highlighted {
    background: linear-gradient(135deg, #a78bfa 0%, #ec4899 100%) !important;
    color: #ffffff !important;
    font-weight: 600 !important;
    box-shadow: 
        0 2px 8px rgba(167, 139, 250, 0.3),
        0 0 0 1px rgba(167, 139, 250, 0.2);
}

/* Mot en attente (prochain) - Opacit√© r√©duite */
.dialogue-text .word.pending {
    color: #9ca3af !important;
    opacity: 0.4 !important;
}

/* D√âSACTIVER TOUTES LES TRANSITIONS - ABSOLUMENT AUCUNE */
.dialogue-text,
.dialogue-text .word,
.dialogue-text .word *,
.dialogue-text .word::before,
.dialogue-text .word::after {
    transition: none !important;
    transition-property: none !important;
    transition-duration: 0s !important;
    transition-delay: 0s !important;
    transition-timing-function: none !important;
    animation: none !important;
    animation-duration: 0s !important;
    animation-delay: 0s !important;
}

/* Animation pulse supprim√©e - plus n√©cessaire avec le CSS simplifi√© */

/* Responsive : ajuster la taille sur mobile */
@media (max-width: 640px) {
    .dialogue-container {
        padding: 20px 15px;
        margin: 20px auto;
    }
    
    .dialogue-text {
        font-size: 16px;
        line-height: 1.7;
    }
    
    .dialogue-text .word {
        padding: 2px 5px;
        margin: 0;
    }
    
    .dialogue-line {
        padding: 10px;
        margin-bottom: 15px;
    }
    
    .speaker-avatar {
        width: 35px;
        height: 35px;
        font-size: 14px;
    }
    
    .message-bubble {
        padding: 12px 15px;
    }
    
    .dialogue-controls-sticky {
        top: 10px;
        padding: 0 10px;
        max-width: 100%;
    }
    
    .dialogue-controls-content {
        padding: 10px 15px;
        gap: 10px;
        flex-wrap: wrap;
    }
    
    .play-all-btn {
        width: 45px;
        height: 45px;
        font-size: 18px;
    }
    
    .speed-control {
        font-size: 12px;
    }
    
    .speed-control select {
        padding: 4px 8px;
        font-size: 12px;
    }
    
    h1 {
        font-size: 1.5rem;
        margin-bottom: 15px;
    }
    
    .course-intro {
        font-size: 0.85rem;
        margin-bottom: 20px;
    }
}

/* Desktop : taille l√©g√®rement plus grande */
@media (min-width: 1024px) {
    .dialogue-text {
        font-size: 18px;
        line-height: 1.8;
    }
}

/* Animation pour les bulles */
@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.dialogue-line {
    animation: slideIn 0.3s ease;
}

.dialogue-line:nth-child(even) {
    animation-delay: 0.05s;
}

/* Animation pulse pour le bouton play */
@keyframes pulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.05);
    }
}

#play-all-btn.playing {
    animation: pulse 2s ease-in-out infinite;
}

audio {
    display: none;
}
</style>

<script>
let dialogueData = null;
let isPlaying = false;
let currentLineIndex = -1;
let audioElements = [];
let globalSpeed = 1.0;
let lastUpdateTime = 0;
const UPDATE_THROTTLE = 16; // ~60fps (16ms entre chaque update)

// Charger et afficher le dialogue
async function loadDialogue() {
    console.log('üé¨ loadDialogue() appel√©e');
    const container = document.getElementById('dialogue-container');
    
    if (!container) {
        console.error('‚ùå dialogue-container non trouv√© dans le DOM');
        return;
    }
    
    container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">Chargement du dialogue...</p>';
    
    try {
        let response;
        const paths = [
            '/dialogues/dialogue-data.json',
            '/dialogue-data.json',
            './dialogues/dialogue-data.json',
            '../dialogues/dialogue-data.json',
            '/public/dialogue-data.json'
        ];
        
        let loaded = false;
        for (const path of paths) {
            try {
                response = await fetch(path);
                if (response.ok) {
                    loaded = true;
                    console.log('‚úÖ Fichier charg√© depuis:', path);
                    break;
                }
            } catch (e) {
                continue;
            }
        }
        
        if (!loaded || !response.ok) {
            // Fallback : utiliser les donn√©es directement
            console.warn('‚ö†Ô∏è Impossible de charger le JSON, utilisation des donn√©es en dur');
            const fallbackData = [{
                "id": "dialogue1",
                "title": "Lundi matin au bureau",
                "lines": [
                    {"speaker": "Julie", "text": "Salut Marc ! √áa va ?", "audioPath": "/dialogues/audio/dialogue1_line0.mp3"},
                    {"speaker": "Marc", "text": "Bof, pas terrible... J'ai pas bien dormi ce week-end. Et toi ?", "audioPath": "/dialogues/audio/dialogue1_line1.mp3"},
                    {"speaker": "Julie", "text": "Ouais, √ßa va. Un peu fatigu√©e aussi. T'as fait quoi ce week-end ?", "audioPath": "/dialogues/audio/dialogue1_line2.mp3"},
                    {"speaker": "Marc", "text": "Pas grand-chose, j'ai regard√© des s√©ries. Et toi ?", "audioPath": "/dialogues/audio/dialogue1_line3.mp3"},
                    {"speaker": "Julie", "text": "Pareil, j'ai pas boug√© de chez moi. Bon, allez, bon courage pour aujourd'hui !", "audioPath": "/dialogues/audio/dialogue1_line4.mp3"},
                    {"speaker": "Marc", "text": "Merci, toi aussi !", "audioPath": "/dialogues/audio/dialogue1_line5.mp3"}
                ]
            }];
            dialogueData = fallbackData.find(d => d.id === 'dialogue1');
            if (dialogueData) {
                renderDialogue(container, dialogueData);
                return;
            }
            throw new Error('Impossible de charger dialogue-data.json');
        }
        
        const dialogues = await response.json();
        dialogueData = dialogues.find(d => d.id === 'dialogue1');
        
        if (!dialogueData) {
            container.innerHTML = 
                '<div style="color: red; text-align: center; padding: 20px;">' +
                '<h3>‚ùå Dialogue non trouv√©</h3>' +
                '</div>';
            return;
        }
        
        renderDialogue(container, dialogueData);
    } catch (error) {
        console.error('Erreur lors du chargement du dialogue:', error);
        const container = document.getElementById('dialogue-container');
        container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #d32f2f;">
                <h3>‚ùå Erreur de chargement</h3>
                <p>${error.message}</p>
                <button onclick="loadDialogue()" style="margin-top: 20px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    üîÑ R√©essayer
                </button>
            </div>
        `;
    }
}

function renderDialogue(container, dialogue) {
    if (!container) return;
    
    // Corriger les chemins audio si n√©cessaire
    const correctedLines = dialogue.lines.map(line => {
        let audioPath = line.audioPath;
        if (audioPath.startsWith('/audio/')) {
            audioPath = audioPath.replace('/audio/', '/dialogues/audio/');
        } else if (audioPath.startsWith('/public/audio/')) {
            audioPath = audioPath.replace('/public/audio/', '/dialogues/audio/');
        }
        return { ...line, audioPath };
    });
    
    // D√©terminer l'alignement altern√©
    const speakers = [...new Set(correctedLines.map(l => l.speaker))];
    const speakerAlignment = {};
    speakers.forEach((speaker, idx) => {
        speakerAlignment[speaker] = idx % 2 === 0 ? 'left' : 'right';
    });
    
    // Diviser le texte en mots pour le karaok√©
    function splitTextIntoWords(text) {
        return text.split(/(\s+)/).filter(w => w.length > 0);
    }
    
    const htmlContent = correctedLines.map((line, index) => {
        const alignment = speakerAlignment[line.speaker] || 'left';
        const words = splitTextIntoWords(line.text);
            const wordsHTML = words.map((word, wordIndex) => {
            const isWord = word.trim().length > 0;
            // √âchapper le HTML pour les textes
            const escapedWord = word.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            // SIMPLIFI√â : juste un span avec la classe word
            return `<span class="word" data-word-index="${wordIndex}" data-line-index="${index}">${escapedWord}</span>`;
        }).join('');
        
        return `
            <div class="dialogue-line ${alignment}" id="line-${index}" data-line-index="${index}">
                <div class="speaker-avatar">${line.speaker.charAt(0)}</div>
                <div class="dialogue-content">
                    <div class="message-bubble">
                        <div class="speaker-name">${line.speaker}</div>
                        <div class="dialogue-text">${wordsHTML}</div>
                        <audio id="audio-${index}" src="${line.audioPath}" preload="metadata"></audio>
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    container.innerHTML = htmlContent;
    
    // Initialiser les √©l√©ments audio
    audioElements = correctedLines.map((line, index) => {
        const audio = document.getElementById(`audio-${index}`);
        if (audio) {
            audio.playbackRate = globalSpeed;
        }
        return audio;
    });
}

function togglePlayAll() {
    if (isPlaying) {
        pauseAll();
    } else {
        playAll();
    }
}

async function playAll() {
    if (!dialogueData || audioElements.length === 0) return;
    
    isPlaying = true;
    const playBtn = document.getElementById('play-all-btn');
    const playIcon = document.getElementById('play-all-icon');
    playBtn.classList.add('playing');
    playIcon.textContent = '‚è∏';
    
    // Trouver o√π on en est : si un audio est en cours de lecture, reprendre depuis l√†
    let startIndex = 0;
    if (currentLineIndex >= 0 && currentLineIndex < audioElements.length) {
        const currentAudio = audioElements[currentLineIndex];
        if (currentAudio && currentAudio.currentTime > 0 && currentAudio.currentTime < currentAudio.duration) {
            // Reprendre depuis la ligne en cours
            startIndex = currentLineIndex;
        } else {
            // Sinon, continuer depuis la ligne suivante
            startIndex = currentLineIndex + 1;
        }
    }
    
    for (let i = startIndex; i < audioElements.length; i++) {
        if (!isPlaying) break; // Arr√™t si pause
        
        currentLineIndex = i;
        const lineElement = document.getElementById(`line-${i}`);
        const audio = audioElements[i];
        
        if (!audio || !lineElement) continue;
        
        // Mettre en surbrillance la ligne active
        document.querySelectorAll('.dialogue-line').forEach(line => {
            line.classList.remove('active');
        });
        lineElement.classList.add('active');
        
        // Scroll vers la ligne
        lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // R√©initialiser le karaok√© seulement si on recommence depuis le d√©but de la ligne
        if (audio.currentTime === 0 || i !== startIndex) {
            resetKaraoke(i);
        }
        
        // Jouer l'audio avec karaok√©
        try {
            await playAudioWithKaraoke(audio, i);
            
            // Micro-pause entre les lignes (500ms)
            if (i < audioElements.length - 1 && isPlaying) {
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        } catch (error) {
            console.error(`Erreur lors de la lecture de la ligne ${i}:`, error);
        }
    }
    
    // Fin de la lecture
    isPlaying = false;
    currentLineIndex = -1;
    playBtn.classList.remove('playing');
    playIcon.textContent = '‚ñ∂';
    document.querySelectorAll('.dialogue-line').forEach(line => {
        line.classList.remove('active');
    });
    resetAllKaraoke();
}

function pauseAll() {
    isPlaying = false;
    // Ne PAS remettre currentTime √† 0 - juste mettre en pause
    audioElements.forEach(audio => {
        if (audio) {
            audio.pause();
            // audio.currentTime reste √† sa position actuelle
        }
    });
    const playBtn = document.getElementById('play-all-btn');
    const playIcon = document.getElementById('play-all-icon');
    playBtn.classList.remove('playing');
    playIcon.textContent = '‚ñ∂';
    // Ne pas retirer la classe 'active' pour garder visuellement o√π on en est
    // document.querySelectorAll('.dialogue-line').forEach(line => {
    //     line.classList.remove('active');
    // });
    // Ne pas r√©initialiser le karaok√© pour garder le surlignage actuel
    // resetAllKaraoke();
}

function playAudioWithKaraoke(audio, lineIndex) {
    return new Promise((resolve, reject) => {
        audio.playbackRate = globalSpeed;
        
        // Si l'audio est d√©j√† en cours (reprise apr√®s pause), mettre √† jour le karaok√© imm√©diatement
        if (audio.currentTime > 0 && audio.currentTime < audio.duration) {
            const duration = audio.duration;
            if (duration > 0) {
                const progress = audio.currentTime / duration;
                updateKaraokeHighlight(lineIndex, progress);
            }
        }
        
        const updateKaraoke = () => {
            if (!isPlaying) return;
            
            // Throttle les mises √† jour pour √©viter les saccades
            const now = performance.now();
            if (now - lastUpdateTime < UPDATE_THROTTLE) {
                return;
            }
            lastUpdateTime = now;
            
            const currentTime = audio.currentTime;
            const duration = audio.duration;
            
            if (duration > 0) {
                // Anticiper l√©g√®rement le surlignage pour une meilleure synchronisation
                const anticipationOffset = 0.1 / duration;
                const progress = Math.min(1, (currentTime / duration) + anticipationOffset);
                // Appeler directement de mani√®re synchrone
                updateKaraokeHighlight(lineIndex, progress);
            }
        };
        
        // Mettre √† jour imm√©diatement au d√©but
        updateKaraoke();
        
        audio.addEventListener('timeupdate', updateKaraoke);
        audio.addEventListener('ended', () => {
            audio.removeEventListener('timeupdate', updateKaraoke);
            resolve();
        }, { once: true });
        audio.addEventListener('error', (e) => {
            audio.removeEventListener('timeupdate', updateKaraoke);
            reject(e);
        }, { once: true });
        
        audio.play().catch(reject);
    });
}

// Cache pour √©viter les recalculs inutiles
let lastHighlightState = new Map();

function updateKaraokeHighlight(lineIndex, progress) {
    const lineElement = document.getElementById(`line-${lineIndex}`);
    if (!lineElement) return;
    
    const words = lineElement.querySelectorAll(`.word[data-line-index="${lineIndex}"]`);
    // Filtrer seulement les mots (pas les espaces)
    const actualWords = Array.from(words).filter(w => w.textContent.trim().length > 0);
    const wordCount = actualWords.length;
    
    if (wordCount === 0) return;
    
    // Calculer le nombre de mots √† surligner de mani√®re plus pr√©cise
    // Utiliser Math.floor pour un surlignage progressif plus fluide
    const highlightedCount = Math.min(wordCount, Math.floor(wordCount * progress));
    
    // V√©rifier si on a d√©j√† appliqu√© cet √©tat (√©vite les changements inutiles)
    if (lastHighlightState.get(lineIndex) === highlightedCount) {
        return; // Pas de changement n√©cessaire
    }
    lastHighlightState.set(lineIndex, highlightedCount);
    
    // APPROCHE ULTIME : Utiliser directement les propri√©t√©s DOM sans passer par CSS
    // et forcer le rendu avec getComputedStyle
    
    // Pr√©parer tous les changements d'abord
    const updates = [];
    
    // Utiliser actualWords au lieu de words pour ignorer les espaces
    actualWords.forEach((word, index) => {
        const shouldBeHighlighted = index < highlightedCount;
        const shouldBePending = index === highlightedCount && progress < 1;
        const isHighlighted = word.classList.contains('highlighted');
        const isPending = word.classList.contains('pending');
        
        if (shouldBeHighlighted && !isHighlighted) {
            updates.push({
                word: word,
                class: 'highlighted',
                removeClass: 'pending'
            });
        } else if (shouldBePending && !isPending) {
            updates.push({
                word: word,
                class: 'pending',
                removeClass: 'highlighted'
            });
        } else if (!shouldBeHighlighted && !shouldBePending && (isHighlighted || isPending)) {
            updates.push({
                word: word,
                class: null,
                removeClass: 'highlighted pending'
            });
        }
    });
    
    if (updates.length === 0) return;
    
    // SIMPLIFI√â : Utiliser UNIQUEMENT les classes CSS - le CSS g√®re le background
    updates.forEach(({ word, class: className, removeClass }) => {
        // G√©rer UNIQUEMENT les classes - le CSS fait tout le reste
        if (removeClass) {
            word.classList.remove(...removeClass.split(' '));
        }
        if (className) {
            word.classList.add(className);
        }
    });
}

function resetKaraoke(lineIndex) {
    const lineElement = document.getElementById(`line-${lineIndex}`);
    if (!lineElement) return;
    
    const words = lineElement.querySelectorAll(`.word[data-line-index="${lineIndex}"]`);
    words.forEach(word => {
        word.classList.remove('highlighted', 'pending');
    });
}

function resetAllKaraoke() {
    document.querySelectorAll('.word').forEach(word => {
        word.classList.remove('highlighted', 'pending');
    });
}

function updateGlobalSpeed() {
    const select = document.getElementById('speed-select');
    globalSpeed = parseFloat(select.value);
    
    // Mettre √† jour la vitesse de tous les audios
    audioElements.forEach(audio => {
        if (audio) {
            audio.playbackRate = globalSpeed;
        }
    });
}

// Charger le dialogue au chargement de la page
function initDialogue() {
    const container = document.getElementById('dialogue-container');
    if (container) {
        loadDialogue();
    } else {
        setTimeout(initDialogue, 100);
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(initDialogue, 100);
    });
} else {
    setTimeout(initDialogue, 100);
}
</script>
